{"version":3,"sources":["../src/immutabix.js"],"names":[],"mappings":"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","file":"src/immutabix.js","sourcesContent":["\n'use strict';\n\nvar Immutable = require('immutable'),\n    server    = require('./server');\n\nvar immutabix = {},\n    ROOT,\n    pathConnectionMap,\n    pathPreviousValueMap,\n    triggerListeners,\n    toKey,\n    fromKey;\n\n//  main root reference\nROOT = Immutable.Map({});\n\npathConnectionMap     = new Map();\npathPreviousValueMap  = new Map();\n\ntoKey = (path) => { return path.join('/'); };\n\nfromKey = (path) => { return path.split('/'); };\n\n/**\n*                         API\n* .getRaw()\n* .resetRoot()\n* .set(path, value)\n* .ref(path, connectionId)\n* .unref(path, connectionId)\n* .registerOnPath(path, connectionId)\n* .deregisterOnPath(path, connectionId)\n* .startServer(configuration)\n*\n*/\n\n\n//  ----------------------------------------- triggerListeners\ntriggerListeners = () => {\n\n  Immutable.Seq( pathConnectionMap.entries() )\n    .filter( entry => {\n\n      var path = entry[0],\n          prevVal = pathPreviousValueMap.get(path),\n          currVal = ROOT.getIn( fromKey(path) ),\n          areSame = Immutable.is(prevVal, currVal);\n\n      //  if the values are NOT the same,\n      if(!areSame){\n        //  set the previous to see what the current does,\n        //  so we don't end up triggering a change again\n        pathPreviousValueMap.set(path, currVal);\n      }\n\n      return !areSame;\n    })\n    .forEach( entry => {\n\n      var path = entry[0],\n          connectionIds = entry[1],\n      //  make the message to be pushed to the listener\n          msg = {\n                  command: 'ref',\n                  path: path,\n                  value: ROOT.getIn( fromKey(path) ).toJS()\n                };\n\n      connectionIds\n      .forEach( (connectionId) => {\n        server.pushMessage(connectionId, msg);\n      });\n    });\n};\n\n\n//  ----------------------------------------- getRaw\nimmutabix.getRaw = () => {\n  return ROOT;\n};\n\n\n//  ----------------------------------------- resetRoot\nimmutabix.resetRoot = () => {\n  ROOT = Immutable.Map({});\n};\n\n\n//  ----------------------------------------- set\nimmutabix.set = (path, value) => {\n\n  if(!Array.isArray(path)){\n    throw new TypeError('.set() expects an Array as 1st argument');\n  }\n\n  if(typeof value === 'object'){\n    value = Immutable.fromJS(value);\n  }\n\n\n  //  map the previous value\n  pathPreviousValueMap.set(toKey(path), ROOT.getIn(path));\n\n  //  set the value\n  ROOT = ROOT.setIn(path, value);\n\n  //  trigger the listeners\n  triggerListeners();\n};\n\n\n//  ----------------------------------------- ref\nimmutabix.ref = (path, connectionId) => {\n\n  if(!Array.isArray(path)){\n    throw new TypeError('.set() expects an Array as 1st argument');\n  }\n\n  //  when a wrong path is given, return an error message\n  if( !ROOT.hasIn(path) ){\n\n    //  make the error message\n    let msg = {\n                command: 'ref',\n                path: path,\n                error: true\n              };\n\n    server.pushMessage(connectionId, msg);\n    return false;\n  }\n\n  immutabix.registerOnPath(path, connectionId);\n  triggerListeners();\n};\n\n\n//  ----------------------------------------- unref\nimmutabix.unref = (path, connectionId) => {\n\n  if(!Array.isArray(path)){\n    throw new TypeError('.set() expects an Array as 1st argument');\n  }\n\n  immutabix.deregisterOnPath(path, connectionId);\n};\n\n\n//  ----------------------------------------- registerOnPath\nimmutabix.registerOnPath = (path, connectionId) => {\n\n  if( !Array.isArray(path)){\n    throw new Error('.registerOnPath(path, connectionId) needs `path` to be an Array');\n  }\n\n  if( isNaN(connectionId) ){\n    throw new Error('.registerOnPath(path, connectionId) needs `connectionId` to be an Number');\n  }\n\n  if( !ROOT.hasIn(path) ){\n    throw new Error(`there is nothing in path:${path}`);\n  }\n\n  //  convert the path array to a key string\n  var key = toKey(path);\n\n  //  if that key is already with one or more listeners...\n  if(pathConnectionMap.has(key)){\n    //  add the key in the map, pointing to the connections\n    //  listening to it, merged in one array\n    pathConnectionMap.set(\n      key,\n      pathConnectionMap.get(key).concat([connectionId])\n    );\n  } else {\n    //  set for the 1st time the path to that connection\n    pathConnectionMap.set(key, [connectionId]);\n  }\n\n};\n\n\n//  ----------------------------------------- deregisterOnPath\nimmutabix.deregisterOnPath = (path, connectionId) => {\n\n  if( !Array.isArray(path)){\n    throw new Error('.deregisterOnPath(path, connectionId) needs `path` to be an Array');\n  }\n\n  if( isNaN(connectionId) ){\n    throw new Error('.deregisterOnPath(path, connectionId) needs `connectionId` to be an Number');\n  }\n\n  //  convert the path array to a key string\n  var key = toKey(path);\n\n  //  if that key is already with one or more listeners...\n  if(pathConnectionMap.has(key)){\n\n    let connectionsArray = pathConnectionMap.get(key);\n    let indexOfOurConnection = connectionsArray.indexOf(connectionId);\n\n    //  if our connection id is in that array, remove it\n    if(indexOfOurConnection > -1){\n\n      //  remove that element\n      connectionsArray.splice(indexOfOurConnection, 1);\n\n      pathConnectionMap.set(\n        key,\n        connectionsArray\n      );\n    }\n  }\n};\n\n\n//  ----------------------------------------- start server\nimmutabix.startServer = (configuration) => {\n\n  server.setDebug(!!configuration.debug);\n\n  server.startServing(configuration);\n\n  //  when the server receives a message...\n  //\n  //  input : {\n  //    connectionId: <number>,\n  //    command: <command>\n  //  }\n  server.onMessage((input) => {\n\n    if(input.command === undefined){\n      return false;\n    }\n\n    //  break down the incoming data\n    var command = input.command;\n\n    switch(command.type){\n\n      case 'set':\n        immutabix.set(command.path, command.value);\n        break;\n\n      case 'unref':\n        immutabix.unref(command.path, input.connectionId);\n        break;\n\n      case 'ref':\n        //  go on with the referencing\n        immutabix.ref(command.path, input.connectionId);\n\n        break;\n    }\n\n  });\n};\n\n\n//  ===========================================================   export\nmodule.exports = immutabix;\n"]}