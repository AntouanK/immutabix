{"version":3,"sources":["src/immutabix.js"],"names":[],"mappings":"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","file":"src/immutabix.js","sourcesContent":["\n'use strict';\n\nvar Immutable = require('immutable'),\n    server    = require('./server');\n\nvar immutabix = {},\n    ROOT,\n    pathConnectionMap,\n    pathValueMap,\n    pathPreviousValueMap,\n    triggerListeners,\n    toKey;\n\n//  main root reference\nROOT = Immutable.Map({});\n\npathConnectionMap     = new Map();\npathValueMap          = new Map();\npathPreviousValueMap  = new Map();\n\ntoKey = (path) => { return path.join('/'); };\n\n\n/**\n*                         API\n* .getRaw()\n* .resetRoot()\n* .set(path, value)\n* .ref(path, connectionId)\n* .unref(path, connectionId)\n* .registerOnPath(path, connectionId)\n* .deregisterOnPath(path, connectionId)\n* .startServer(configuration)\n*\n*/\n\n\n//  ----------------------------------------- triggerListeners\ntriggerListeners = () => {\n\n  Immutable.Seq( pathConnectionMap.entries() )\n    .filter( entry => {\n\n      let path = entry[0];\n\n      return pathPreviousValueMap.get(path) !== pathValueMap.get(path);\n    })\n    .forEach( entry => {\n\n      let path = entry[0];\n      let connectionIds = entry[1];\n      //  make the message to be pushed to the listener\n      let msg = {\n                  command: 'ref',\n                  path: path,\n                  value: pathValueMap.get(path)\n                };\n\n\n      connectionIds\n      .forEach( (connectionId) => {\n        server.pushMessage(connectionId, msg);\n      });\n    });\n};\n\n\n//  ----------------------------------------- getRaw\nimmutabix.getRaw = () => {\n  return ROOT;\n};\n\n\n//  ----------------------------------------- resetRoot\nimmutabix.resetRoot = () => {\n  ROOT = Immutable.Map({});\n};\n\n\n//  ----------------------------------------- set\nimmutabix.set = (path, value) => {\n\n  if(!Array.isArray(path)){\n    throw new TypeError('.set() expects an Array as 1st argument');\n  }\n\n  if(typeof value === 'object'){\n    value = Immutable.fromJS(value);\n  }\n\n\n  //  map the previous value\n  pathPreviousValueMap.set(toKey(path), pathValueMap.get(toKey(path)));\n\n  //  set the value\n  ROOT = ROOT.setIn(path, value);\n\n  //  map the current value\n  pathValueMap.set(toKey(path), value);\n\n  //  trigger the listeners\n  triggerListeners();\n};\n\n\n//  ----------------------------------------- ref\nimmutabix.ref = (path, connectionId) => {\n\n  if(!Array.isArray(path)){\n    throw new TypeError('.set() expects an Array as 1st argument');\n  }\n\n  if(!ROOT.hasIn(path)){\n    return undefined;\n  }\n\n  immutabix.registerOnPath(path, connectionId);\n  triggerListeners();\n};\n\n\n//  ----------------------------------------- unref\nimmutabix.unref = (path, connectionId) => {\n\n  if(!Array.isArray(path)){\n    throw new TypeError('.set() expects an Array as 1st argument');\n  }\n\n  immutabix.deregisterOnPath(path, connectionId);\n};\n\n\n//  ----------------------------------------- registerOnPath\nimmutabix.registerOnPath = (path, connectionId) => {\n\n  if( !Array.isArray(path)){\n    throw new Error('.registerOnPath(path, connectionId) needs `path` to be an Array');\n  }\n\n  if( isNaN(connectionId) ){\n    throw new Error('.registerOnPath(path, connectionId) needs `connectionId` to be an Number');\n  }\n\n  if( !ROOT.hasIn(path) ){\n    throw new Error(`there is nothing in path:${path}`);\n  }\n\n  //  convert the path array to a key string\n  var key = toKey(path);\n\n  //  if that key is already with one or more listeners...\n  if(pathConnectionMap.has(key)){\n    //  add the key in the map, pointing to the connections\n    //  listening to it, merged in one array\n    pathConnectionMap.set(\n      key,\n      pathConnectionMap.get(key).concat([connectionId])\n    );\n  } else {\n    //  set for the 1st time the path to that connection\n    pathConnectionMap.set(key, [connectionId]);\n    //  set for the 1st time, the path to it's value reference\n    pathValueMap.set(key, ROOT.getIn(path));\n  }\n\n};\n\n\n//  ----------------------------------------- deregisterOnPath\nimmutabix.deregisterOnPath = (path, connectionId) => {\n\n  if( !Array.isArray(path)){\n    throw new Error('.deregisterOnPath(path, connectionId) needs `path` to be an Array');\n  }\n\n  if( isNaN(connectionId) ){\n    throw new Error('.deregisterOnPath(path, connectionId) needs `connectionId` to be an Number');\n  }\n\n  //  convert the path array to a key string\n  var key = toKey(path);\n\n  //  if that key is already with one or more listeners...\n  if(pathConnectionMap.has(key)){\n\n    let connectionsArray = pathConnectionMap.get(key);\n    let indexOfOurConnection = connectionsArray.indexOf(connectionId);\n\n    //  if our connection id is in that array, remove it\n    if(indexOfOurConnection > -1){\n\n      //  remove that element\n      connectionsArray.splice(indexOfOurConnection, 1);\n\n      pathConnectionMap.set(\n        key,\n        connectionsArray\n      );\n    }\n  }\n};\n\n\n//  ----------------------------------------- start server\nimmutabix.startServer = (configuration) => {\n\n  server.setDebug(!!configuration.debug);\n\n  server.startServing(configuration);\n\n  //  when the server receives a message...\n  //\n  //  input : {\n  //    connectionId: <number>,\n  //    command: <command>\n  //  }\n  server.onMessage((input) => {\n\n    if(input.command === undefined){\n      return false;\n    }\n\n    //  break down the incoming data\n    var command = input.command;\n\n    switch(command.type){\n\n      case 'set':\n        immutabix.set(command.path, command.value);\n        break;\n\n      case 'unref':\n        immutabix.unref(command.path, input.connectionId);\n        break;\n\n      case 'ref':\n        //  when a wrong path is given, return an error message\n        if( !ROOT.hasIn(command.path) ){\n\n          //  make the error message\n          var msg = {\n                      command: 'ref',\n                      path: command.path,\n                      error: true\n                    };\n\n          server\n          .pushMessage(input.connectionId, msg);\n        }\n\n        //  go on with the referencing\n        immutabix.ref(command.path, input.connectionId);\n\n        break;\n    }\n\n  });\n};\n\n\n//  ===========================================================   export\nmodule.exports = immutabix;\n"]}